1. Самый важный фактор в разработке ПО - это не методы и средства, применяемые программистами, а сами программисты. 

2. По результатам исследования персональных отличий лучшие программисты до 28 раз превосходят слабейших. Если учесть, что оплата их труда никогда не бывает соразмерной, то лучший программист и есть самое выгодное приобретение в индустрии ПО.

3. Если проект не укладывается в сроки, то добавление рабочей силы задержит его еще больше. 

4. Условия труда оказывают сильное влияние на продуктивность и качество результата. 

5. Рекламный звон вокруг инструментов и методов - это чума индустрии ПО. Большая часть усовершенствований средств и методов приводит к увеличению производительности и качества примерно на 5-35%. Но многие из этих усовершенствований были заявлены как дающие преимущество "на порядок". 

6. Изучение нового метода или средства сначала понижает производительность программистов и качество продукта. Пользу из обучения можно извлечь только после того, как пройдена кривая обучения. Поэтому вводить новые методы и средства имеет смысл, только если, а) видеть их реальную ценность и б) проявлять терпение в ожидании выигрыша. 

7. Разработчики много говорят об инструментальных средствах. Они пробуют довольно многие, приобретают их в достаточном количестве, но практически не работают с ними. 

8. Чаще всего одной из причин неуправляемости проекта является плохая оценка (вторая причина 23). 

9. Большинство оценок в проектах ПО делается в начале жизненного цикла. И это не смущает нас, пока мы не понимаем, что оценки получены раньше, чем определены требования, и соответственно раньше, чем задача изучена. Следовательно, оценка обычно делается не вовремя. 

10. Большинство оценок в проектах ПО делают либо топ-менеджеры, либо сотрудники, занимающиеся маркетингом, а вовсе не те, кто будет создавать ПО, или их руководители. Таким образом, оценку делают не те люди. 

11. Оценки в проектах ПО редко уточняются впоследствии. Другими словами, оценки, сделанные не теми людьми и не в то время, как правило, не корректируются. 

12. Раз оценки настолько неправильны, то не так уж много причин беспокоиться о том, что программные проекты не завершаются в сроки, задаваемые оценками. Однако всех это беспокоит. 

13. Между менеджерами и программистами нет контакта. В одном исследовании, посвященном проекту, в котором не были соблюдены параметры, заданные на основании оценки, и который рассматривался руководством как неудачный, говорится, что технические исполнители отозвались о нем как о самом удачном проекте, над которым они когда-либо работали. 

14. Анализ осуществимости проекта почти всегда дает ответ "да". 

15. Повторное использование "в миниатюре" (в библиотеках подпрограмм) появилось почти 50 лет назад, и решение этой задачи отработано хорошо. 

16. Задача повторного использования "в крупном масштабе" (в компонентах) остается по большей части нерешенной, хотя все согласны с тем, что сделать это очень важно. 

17. Успех повторного использования в крупном масштабе бывает максимальным в семействах родственных систем и потому зависит от предметной области. Это сужает потенциальную применимость повторного использования в крупном масштабе. 

18. В практике повторного использования есть два "правила трех" а) многократно используемые компоненты в три раза более трудоемки, чем одноразовые компоненты; и б) многократно используемый компонент должен быть испробован в трех различных приложениях, прежде чем его можно будет считать достаточно общим, чтобы допустить в библиотеку компонентов. 

19. Модификация повторно используемого кода крайне чревата ошибками. Если надо изменить более 20-25% кода компонента, то лучше переписать его с самого начала. 

20. Повторное использование паттернов проектирования - это решение проблем, сопутствующих повторному использованию кода. 

21. Увеличении сложности задачи на 25% приводит к усложнению программного решения на 100%. Это не условие, которое можно попытаться изменить (хотя сложность всегда желательно свести к минимуму), это реальное положение дел.

22. Восемьдесят процентов работ по создании ПО приходится на интеллектуальную деятельность. Изрядную долю последней можно смело отнести к креативной. И лишь небольшую часть - к технической. 

23. Одной из двух самых распространенных причин неуправляемости проектов являются изменчивые требования. (первая в 8).

24. Исправление ошибок в требованиях обходится дороже всего, если они обнаружены на этапе эксплуатации, и дешевле всего, если это происходит на ранних этапах разработки. 

25. Требования, которых нет, - это такая ошибка, исправить которую труднее всего. 

26. По мере продвижения от начальных требований к архитектуре на нас обрушивается шквал «производных требований» (требований к конкретному проектному решению), вызванный сложностью процесса. Список этих производных требований часто в 50 раз длиннее изначального. 

27. Лучшее проектное решение задачи программирования редко бывает единственным. 

28. Проектирование – это сложный итеративный процесс. Первоначальное проектное решение, скорее, всего окажется неверным и, безусловно, не оптимальным. 

29. Программисты переходят от проектирования к кодированию тогда, когда задача разобрана до уровня «примитивов», которыми владеет проектировщик. Если кодировщик и проектировщик – это разные люди, то примитивы проектировщика, вероятно, не будут совпадать с примитивами кодировщика и это приведет к неприятностям. 

30 Фаза устранения ошибок – самая трудоемкая в жизненном цикле. 

31. Оказывается, что в ПО, о котором типичный программист думает, что оно тщательно протестировано, нередко проверено выполнение лишь 55-60% логических путей. Применение автоматизированных средств, таких как анализаторы покрытия, позволяет повысить эту долю примерно до 85-90%. Протестировать 100% логических путей ПО практически невозможно. 

32. Даже если бы 100% тестовое покрытие было возможно, оно не годилось бы на роль критерия достаточности тестирования. Примерно 35 % дефектов ПО вызвано пропущенными логическими путями и еще 40% связаны с выполнением уникальной комбинации логических путей. Их не выявить при 100% покрытии тестами. 

33. Тесты редко автоматизируются. То есть определенные процессы тестирования могут и должны быть автоматизированы. Но значительную часть работы, связанной с тестированием, автоматизировать нельзя. 

34. Тщательные инспекции дают множество выгод, но они не могут заменить тестирование. 

35. Общепризнано, что обзоры, сделанные постфактум (их также называют ретроспективными), важны как с точки зрения интересов потребителя (пользователя ПО), так и с точки зрения совершенствования процесса. Однако в большинстве организаций ретроспективные обзоры не делаются. 

36. В инспекциях наряду с техническими факторами присутствует и социальный. Уделить большее внимание чему-то одному в ущерб другому – прямой путь к катастрофе. 
37. Стоимость сопровождения обычно составляет от 40 до 80 % (в среднем 60%) стоимости ПО. Следовательно, эта фаза его жизненного цикла, возможно, самая важная. 

38. Примерно 60% расходов на сопровождения приходится на улучшения кода и около 17% - на исправление ошибок. Таким образом, в основном сопровождение и поддержка ПО заключается в добавлении в него новых возможностей, а не в его исправлении.

39. Сопровождение – это решение, а не проблема.

40. Если сравнивать задачи разработки и сопровождения ПО, то они по большей части одинаковы, - за исключением дополнительной задачи сопровождения, формулируемой как «изучение сопровождаемого продукта». Она занимает примерно 30% времени, уходящего на сопровождение в целом, и этот вид деятельности преобладает в сопровождении. Таки образом, можно сказать, что сопровождение более трудоемко, чем разработка. 

41. Улучшение качества разработки ПО приводит к тому, что сопровождения становится больше, а не меньше. 

42. Качество есть совокупность свойств. 

43. Качество не определяется удовлетворением пользователя, соответствием требованиям заказчика, приемлемостью цены и соблюдением сроков сдачи продукта, и надежностью. 

44. Есть такие ошибки, к которым предрасположено большинство программистов. 

45. Ошибки имеют тенденцию образовывать скопления. 

46. Для устранения ошибок еще не выработан какой-то один, лучший подход. 

47. От ошибок никуда не деться. Цель состоит в том, чтобы избежать критических ошибок или свести их к минимуму. 

48. Эффективность больше зависит от качественного проектирования приложения, чем от качественного программирования. 

49. Многие ученые, работающие в индустрии программирования, склонны скорее защищать свои теории, чем заниматься исследованиями. Результат: а) ценность некоторых пропагандируемых теорий намного меньше, чем думают сами пропагандисты; б) мало исследований, призванных помочь определить, какова же истинная ценность этих теорий. 




Заблуждение 1. Невозможно управлять тем, что невозможно измерить.   
Заблуждение 2. Менеджмент может сделать программный продукт качественным.    
Заблуждение 3. Программирование может и должно быть обезличенным.    
Заблуждение 4. Инструменты и технологии универсальны.    
Заблуждение 5. Программирование нуждается в большем количестве методологий.    
Заблуждение 6. Чтобы оценить затраты и определить сроки, сначала сосчитайте строки кода.   
Заблуждение 7. Использование случайных входных данных – хороший способ оптимизировать тестирование.    
Заблуждение 8. Все ошибки становятся заметными, если на них обращено достаточно много глаз.    
Заблуждение 9. Зная, во что обошлась поддержка в предыдущем случае, можно предсказать, во что она обойдется в будущем, и принять решение о целесообразности замены продукта.    
Заблуждение 10. Людей можно научить программированию, показывая им, как писать программы.    




Проект считался успешным у программистов потому что :   
• Продукт работал должным образом (здесь ничего нового).    
• Разработка этого продукта была технически сложной задачей.   
(Многочисленные данные показывают, что больше всего технические специалисты обожают решать трудные задачи.) 
• Команда была малочисленной, работала с высокой отдачей.    
• Команда менеджеров была «лучшей, с какой я когда либо работал».   
Почему? «Поскольку команде была дана свобода на разработку хорошей архитектуры», поскольку не было «расползания проекта» (scope creep) и поскольку «не давили сроки». И участники добавили кое-что еще.    
Линберг поинтересовался, что они думают о причинах нарушения сроков. Они назвали такие:    
• Назначенные по результатам оценки сроки были нереалистичными (ага!).   
• Было недостаточно ресурсов, в частности не хватало консультаций экспертов.    
• Когда проект начинался, мы плохо представляли себе его масштаб.    
• Проект поздно стартовал.    

Во всем этом есть кое-что особенное. Все эти параметры были справедливы на начало проекта. Не в середине проекта, а в его начале. Другими словами, жребий проекта был предрешен с первого дня. Как бы хорошо и как бы упорно эти специалисты ни работали, едва ли они оправдали бы ожидания руководства. В этих условиях они делали то, что с их точки зрения было лучшим, что им оставалось делать. Они с пользой провел время, создав пригодный продукт. 


Те, кто изучал задачи сопровождения ПО, признают, что есть одна задача, по сложности превосходящая все остальные задачи модификации ПО. Задача эта состоит в том, чтобы понять имеющееся решение. Хорошо известно, что даже программисту, которому принадлежит авторство изначального решения, непросто модифицировать его по прошествии нескольких месяцев.


Для преодоления этих трудностей разработчики изобрели понятие эксплуатационной документации –документации, в которой описана работа программы и пояснено, почему программа работает именно так. Часто подобную документацию начинают создавать одновременно с оригинальным проектным документом, который служит для нее основой. Но здесь мы сталкиваемся с еще одним феноменом, характерным для индустрии ПО. Все признают, что эксплуатационная документация необходима, но когда возникает угроза превышения бюджета программного проекта или нарушения его сроков, поэтому в первую очередь обычно отказываются именно от документации. В результате программных систем, сопровождаемых адекватной эксплуатационной документацией, практически нет.


Более того, во время работ по сопровождению, когда программный продукт модифицируется (а модернизация ПО – это основной вид деятельности в программировании, как мы увидим в Факте 42), эксплуатационную документацию, какая бы она ни была, редко приводят в соответствие с изменениями ПО. Получается, что эксплуатационная документация может существовать или ее может не быть вовсе, но даже если она существует, она скорее всего устарела и потому малодостоверна. По этим причинам выполнение большинства работ по сопровождению требует чтения кода.


• Почему так важен человеческий фактор? (Потому что для преодоления сложностей требуются значительные умственные способности и мастерство.)   
• Почему так сложно оценивать? (Потому что наши решения намного сложнее, чем выглядят наши задачи.)   
• Почему масштабное повторное использование так безуспешно? (Потому что сложность делает проблему многообразия более выраженной.)   
• Почему количество технических требований растет лавинообразно
(по мере того как мы продвигаемся от требований к проектированию, явные требования перерастают в чрезвычайно более много: численные неявные, необходимые для создания работающей архитектуры)? (Потому что мы движемся из «двадцатипятипроцентной» части вселенной в сторону «стопроцентную».)   
• Почему так много различных корректных подходов к проектированию решения одной задачи? (Потому что пространство решений так многогранно.)   
• Почему лучшие проектировщики выбирают итеративные и эвристические подходы? (Потому что простые и очевидные проектные решения встречаются редко.)   
• Почему проектное решение редко оптимизируется? (Поскольку оптимизация практически невозможна ввиду значительной сложности.)   
• Почему стопроцентный уровень тестового покрытия редко возможен и в любом случае недостаточен? (Вследствие громадного числа веток в большинстве программ и поскольку программная сложность приводит к ошибкам, которые не удается отловить.)   
• Почему инспекция (рецензирование) является наиболее эффективным методом устранения ошибок? (Потому что нужен человек, чтобы разложить всю эту сложность по полочкам и распознать ошибки.)   
• Почему сопровождение ПО отнимает столько времени? (Потому что в самом начале почти никогда нельзя определить все ответвления решения задачи.)   
• Почему понять, как устроен готовый продукт, – это самая главная и сложная задача сопровождения ПО? (Потому что существует масса корректных методов решения любой задачи.)   
• Почему программы содержат столько ошибок? (Потому что трудно сделать все правильно с самого начала.)   
• Почему исследователи программирования прибегают к пропаганде? (Наверное, дело в том, что в мире сложного ПО слишком трудно проводить чрезвычайно нужные оценочные исследования, которые должны предшествовать пропаганде.)   



Но вернемся немного назад и определим, что же такое жизненный цикл. Он начинается с определения и разработки требований; здесь определяется и анализируется условие задачи. За ним следует проектирование, в котором устанавливается, как предстоит решать задачу. За ним идет кодирование, где проектное решение трансформируется в код, который будет исполняться на компьютере. Затем, поскольку все это чревато ошибками, проводится устранение ошибок. И наконец, когда пройдены все тесты, программный продукт запускают в эксплуатацию, и начинается этап сопровождения. 


Для большинства задач в программировании можно найти несколько решений. Это по поводу слова единственное. А уж узнать, является ли найденное решение «лучшим», даже если бы оно было единственным, крайне трудно. Это по поводу слова лучшее.


Разрешите мне сделать небольшое отступление. К тому, что я только что сказал о пробуксовывающем ПО, надо кое:что добавить. Мой австралийский коллега Стив Дженкин (Steve Jenkin) изложил мне свой взгляд на скорость, с которой развивается программирование как профессия. Средний уровень мастерства, сказал он, с течением времени, похоже, не меняется. На первый взгляд звучит странно, правда? Он, однако, имелв виду то, что на фоне лавинообразного притока новых сил в эту бурно развивающуюся отрасль растущее мастерство стареющих специалистов более чем превосходит низкую квалификацию новичков, прибывающих ордами. Немного поразмыслив над словами Стива, я пришел выводу:   
Мудрости в индустрии ПО не становится больше.    
А если не растет мастерство, то и мудрости не прибавляется. В безумном беге к новому мы отвергаем многое из старого. (Например, в самых последних и популярных новинках, таких как экстремальное программирование и гибкое программирование (Extreme и Agile), прослеживается
тенденция к отказу от положительного опыта, накопленного более старыми методологиями.


Правило 60/60: 60% затрат на производство ПО составляют затраты на сопровождение, а 60% от них составляют затраты на модернизацию. Таким образом, модернизация старого ПО имеет важнейшее значение.


1. Переносимость означает, что программный продукт можно без труда перенести на другую платформу.
2. Надежность – это свойство программного продукта надлежащим образом выполнять свои функции.
3. Под эффективностью программного продукта понимают экономное расходование им времени и занимаемого места.
4. Принятие в расчет человеческого фактора (что называют также словом «юзабилити») подразумевает, что с программным продуктом легко и удобно работать.
5. Тестируемость ПО есть не что иное, как свойство, характеризующее легкость его тестирования.
6. Понятность ПО – это свойство, характеризующее, насколько легко (или трудно) специалисту, сопровождающему программный продукт, понять его работу.
7. Модифицируемым называют ПО, изменение которого не вызывает трудностей


Затем, говорил я им, что структуры данных представляют собой компромисс между увеличением сложности их архитектуры и повышением эффективности доступа к их содержимому.
